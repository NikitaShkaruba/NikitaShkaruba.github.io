---
title: "Postgresql и Rails"
ref: Postgresql-and-rails
layout: post
lang: ru
---

Привет, сегодня хотел рассказать об объектно-реляционных базах данных(бд - далее), систем управления базами данных(СУБД - далее)
и PostgreSQL в частности. В конце будет приведён небольшой пример настроенного с PostgreSQL rails-приложения.

### Что же такое база данных?
Итак, база данных - ~~просто база данных, чего непонятного?~~ просто множество упорядоченной информации, хаха :smile:  

Тогда следующий вопрос(Для студента первого курса программной инженерии, сдающего ОВТ), а вот библиотека или какой-нибудь справочник-книга - база данных?   
Ну нет! У программистов какие-то свои базы данных.   

Короче, базы данных в нашем понимании - просто такой способ упорядочивания информации,
чтобы с ним могла автоматически работать специальная прогрмма(СУБД). Способ упорядочивания -
представдение данных(В виде таблиц или объектов) и метаданные(описание адресов таблиц, к примеру)

Способов упорядочивания информации может быть разным, от этого и типов баз данных много, например:  

* *Реляционная база данных* - данные хранятся в таблицах, которые могу ссылаться(relation - cвязь) друг на друга.
* *Объектная база данных* - объектная структура, т.е. обычная куча любой вртуальной машины.
* *Объектно-реляционная база данных* - Реляционная бд с *встроенной поддержкой наследования*, *кастомными методами*, и
*кастомными типами*, а не только стандартными TEXT, INTEGER, а например, типом PERSON.
* *Иерархическая база данных* - древовидная структура, где некоторые объекты включены друг в друга по старшинству. Например,
объект покупатель(предок) включал бы в себя несколько заказов(потомок), которые включали бы в себя какие-нибудь
покупки(потомок потомка)
* *Сетевая база данных* - аналагична иерархической базе данных, но потомки могут имень несколько предков

Ещё раз, для дураков, я вот всегда любил читать такие предложения :smile:
База данных - просто файл с кучей таблиц и метаданными(самоописанием, т.е. тому, как она устроена). Благодаря
метаднным СУБД знает, где же находится та или иная таблица, и может добавлять, читать, изменять и удалять информацию.

### Что такое Система Управления Базами Данных?
СУБД - программа для манипуляции бд, всё :laughing:
Например, вот сейчас у меня есть PostgreSQL, и я мгу написать следующее

```sql
# Зайдём по пользователем postgres
$ sudo -u postgres psql

# Попросим все доступные таблица из бд
postgres=# select * from information_schema.tables

# Cоздадим новую таблицу
postgres=# CREATE TABLE table_name(
   name TEXT,
   surname TEXT,
   PRIMARY KEY(surname)
);
```

СУБД состоит из:

* Ядра, которое отвечает за управление данными во внешней и оперативной памяти и журнализацию,
* Машинно-независимого языка для доступа к данным
* Процессора языка базы данных, обеспечивающий оптимизацию запросов на извлечение и изменение данных.
* Подсистемы поддержки времени исполнения, как-бы интерпретатор sql-запросов.

### Зачем нужны БД и СУБД?
Ну вот представьте, вам нужно сохранить множества записей в таблицах, да ещё и так,
чтобы это всё было логически связано и быстро работало. Почему-бы не хранить данные в
json или xml и не быть счастливыми? Да потому что раньше так и делали, а потом нашли
недостатки у этого подхода, и придумали базы данных.  
Итак, что-же можно делать с бд, чего нельзя делать с простым хранением в каком-либо стандартном формате:

1. Можно запрашивать данные из бд (задавать ей вопросы :smile:), и это всё быстрей самописных алгоритмов поиска
2. Можно строить связи между сущностями, а так-же соединять запрошенные данные
3. Хранение в особой структурe данных, которая и делает всё относительно быстрым
4. Инофрмация оного объекта хранится в еинственном экземпляре из-за связей
5. ACID(Atomicity, Consistency, Isolation, Durability), если вкратце, то одновременные операции над бд не будут друг-другу мешать.
6. Базы данных простительны к ошибкам, например, можно частично восстанавливать базы данных :dissapointed:
7. Базы данных могут обрабатывать реально огромные множества данных.
С другом на одном Джава-проекте тащили порядка ста тысяч сущностей где-то секунд за 15 :smile:
8. Базы данных хорошо расширяются
9. Записи и удаления могу откладываться до момента необходимости, чтобы не занимать процессорное время
10. Логи

### Реляционные базы данных:
Тут есть немного терминологии. Суть:
Каждая строка в таблице - запись, она уникальна, и хоть одной колонкой обязана отличаться.
Данные представлены таблицами. В каждой таблице есть уникальный ключ, который помогает инедтифицировать каждую запись, и только одну.
Например, в таблице с колонками Фамилия-Имя ключом может быть фамилия. Естественный ключ.  

![natural key](/resources/images/natural-key.png)

Но а что, если фамилии повторяются?
Тогда ключом может быть новая колонка ID - суррогатный ключ.  

![surrogate key](/resources/images/surrogate-key.png)

Или комбинация Имени и Фамилии - составным ключом.
Или же можно придумать Интеллектуальный ключ - составленный из данных в таблце.

Также, в записях могу содержаться ссылки на первичные ключи других таблиц - внешние ключи.
Store_id и author_id - внешние ключи.

![foreign key](/resources/images/foreign-keys.png)

Связи между таблицами могут быть:

* Одна или ноль
* Только один
* Много или ноль
* Много или один

Для удобной работы человеку нужна схема бд. Так вот, схема бд будет выглядеть примерно так:

![natural key](/resources/images/db-scheme.png)

#### Да простит меня https://quickleft.com , у которого я стырил картинки.
Скоро вставлю свои :smile:

### CRUD и Язык SQL
Есть такое понятие как базовые операции CRUD - Create, Read, Update, Delete
Так вот, в любой базе данных они релизованы языком запросов.

C - create

```sql
# Создадим бд
create database sample_db;

# Начнём её исопльзовать
use sample_db;

# Создадим в ней таблицу иэнеджеры
create table managers (
id int,
FirstName varchar(255),
SurName varchar(255),
home_city varchar(255),
salary int,
age int,
);
```

R - read

```sql
# показть все доступные базы-данных
show databases;

# Выбрать всю информацию о всех менеджеров
select * from managers;
# Из всех менеджеров с именем Nigel выбрать фамилии и возраст, если они не из Москвы, или если им 20
select surname, age from managers where home_city <> 'Moscow' and name = "Nigel" or age = 20;
# Из всех менеджеров выбрать имена, фамилии и возраст, упорядочить по имени
select name, surname, age from managers order by name;
```

U - update

```sql
# Омолодить на один год всех моих тесок, а так-же, поднять им зарплату
update managers set age = age - 1, salary = salary + 100500 where name = "Nikita";
```

D - delete

```sql
# Зыков - не менеджер, он программист! Перевести его из менеджеров в программисты
insert into programmers select * from managers where surname = "Zykov";
delete from managers where surname = "Zykov";

# Дропнем таблицу
drop table managers;
# Дропнем целую бд! Аккуратно!
drop database sample_db;
```

Также, есть крутые фичи в запросах типо объединения некоторых запросов, их группировки, вложенные запросы, вот:

Группировка - схлопывание запросов с одинаковыми свойствами: group by {property}
Было:

| surname  |   salary    |
|----------|-------------|
| Shkaruba |     4500.00 |
| Shkaruba |     5500.00 |
| Kjelberg |    10000.00 |

```sql
select name, sum(salary) from programmers group by surname;
```

Результат:

| surname  | sum(salary) |
| -------- |:-----------:|
| Shkaruba |    10000.00 |
| Kjelberg |    10000.00 |


Join - склеивание информации из разных таблиц в один результат:

Orders:

| OrderID |	CustomerID | OrderDate  |
| 10308   |	2	         | 1996-09-18 |
| 10309	  | 2 	       | 1996-09-19 |
| 10310	  | 3 	       | 1996-09-20 |

Customers:

| CustomerID	| CustomerName	      | ContactName	                        |
| 1           | Alfreds Futterkiste |	Maria Anders	                      | 	
| 2	          | Ana Trujillo        | Emparedados y helados	Ana Trujillo	|
| 3	          | Antonio Moreno      |  Taquería	Antonio Moreno	          |

```sql
select Orders.OrderID, Customers.CustomerName, Orders.OrderDate
from Orders
inner join Customers
on Orders.CustomerID=Customers.CustomerID;
```

result:

| OrderID	| CustomerName   | OrderDate  |
| 10308   | Ana Trujillo   | 1996-09-18 |
| 10309	  | Ana Trujillo   | 1996-09-19 |
| 10310	  | Antonio Moreno | 1996-09-20 |

Join'ы бывают 6ти типов:

* inner join: возвращает строки, когда совпадение обнаружено в обеих таблицах
* left join: возвращает все строки из левой(первой) таблицы, а так-же когда совпадение обнаружено в обеих таблицах
* right join: возвращает все строки из правой(второй) таблицы, а так-же когда совпадение обнаружено в обеих таблицах
* full join: возвращает все строки из обеих таблиц
* self join: возвращает строки, когда совпадение обнаружено у самой себя ``` select a.id from managers a, managers b where a.salary < b.salary;```
* cross join: возвращает как-бы произведения таблиц, где каждая запись слева имеет пару с каждой записью справа.

Ну, и влоенные запросы это так:

```sql
select * from managers where id in (select id from programmers);
```

Вложенность может быть любой глубины.

### Функции
Ой, ну есть тут функции, как и везде.
Примеры: sum(), avg(), count(), len(),  round(), и прочее.

### Как базы данных используются в программировании
Короче, большинство языков программирования - Объектно-ориентированы, а в бд хранятся таблицы.
Поэтому есть Object Relational Mapping frameworks(Orm-frameworks далее), которые предоставляют объектно-ориентированный
API, обёрнутый над табличным для твоих нужд. Другими словами orm-framework'и как-бы адаптируют
табличное представление в объектное, предоставляя методы классов, в которых инкапсулирована логика запросов.

Пример, стыренный с вики:
Руками пишем запрос, тянем пользователя с id = 10.

```c#
String sql = "SELECT ... FROM persons WHERE id = 10";
DbCommand cmd = new DbCommand(connection, sql);
Result res = cmd.Execute();
String name = res[0]["FIRST_NAME"];
```

Используем orm-framework. Вся логика запросов инкапсулирована в методе GetPerson(id);
```c#
Person p = repository.GetPerson(10);
String name = p.getFirstName();
```

Когда я смотрю на реализацию ORM в Ruby on Rails, мне хочется плакать от счастья, это прекрасно.
Там вся логика обёрнута в ActiveRecord шаблон проектирования.

```ruby
class Article < ActiveRecord::Base
end
```

Всё, можно пользтоваться :scream:
Эти две строчки значат, что таблица в бд "articles" будет смэплена на этот класс, и
у нас есть доступ ко всем его полям + к множеству методов ActiveRecord родительского класса.

Пример использования:

```ruby
Article.create(title:'ORM', author:'Manu')
article = Article.find(:first)
Article.find(:first).destroy
```

#### Ну всё, ты успешен!
Теперь ты знаешь, что же такое База данных, Система управления базой данных, знаешь,
зачем их используют. Слышал о разных типах бд, познакомился с синтаксисом sql. А ты неплох!

Эй, до встречи :smile: И оставайся, таким же офигенным, читатель :wink:
