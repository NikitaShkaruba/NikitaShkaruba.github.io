---
title: "Привет, регулярные выражения"
ref: hello-regular-expressions
layout: post
lang: ru
---

Привет, сегодня хотел затронуть тему *Регулярных выражений* - мощнейший инструмент для работы с текстом. используется для валидации текста,
выборки текста. В программировании без них никуда
Когда-нибудь видел маски типо "\*.pdf" или "123.???", так вот регулярные варыжения - просто очень сильные маски.

### Реализация в Руби (для последующих примеров)
В руби регулярные выражения встроены в сам язык. Используются следующими способами:

* Оператор `=~`, узнающий позицию вхождения в строке

```ruby
"Pretty notation" =~ /notation/ # => 7
"wtf" =~ regex                  # => nil
```

* Regex.match - метод, возвращающий объект `<MatchData>`, хранящий в себе различную информацию

```ruby
matchData = /mismatch/.match("What is regex?") # => nil#
matchData = /(Java).*(ruby)/.match("Java is good, but I am so in love with ruby!")  # => <MatchData>

# Захваченные группы
matchData.captures        # => ["Java", "ruby"]
matchData[0]              # => "Java"
matchData.captures 0              # => "Java"

# Позицию первого вхождения группы
matchData.begin(0)        # => 0    Позиция вхождения самого регулярного выражения
matchData.begin(1)        # => 0    Позиция группы 1
matchData.begin(2)        # => 39   Позиция группы 2

# Строки до и после вхождения
matchData.pre_match       # => ""
matchData.post_match      # => "!"
```

### Основы
Любяа последовательность символов, помещённая в регулярное выражение ищет полностью сама себя

```ruby
"ab" =~ /abc/                     # => nil
"abc" =~ /abc/                    # => 0
"christmas" =~ /Merry christmas/  # => nil
"Nick" =~ /Nick/                  # => 0
```

В регулярных выражениях можно использовать подстановочные символы, которые ищут сразу же несколько символов  
'.' - подстановка любого символа

```ruby
"health" =~ /.ealth/       # => 0
"wealth" =~ /.ealth/       # => 0
```

[some symbols] - подстановка любого символа из перечисленных внутри

```ruby
"health" =~ /[hw]ealth/       # => 0
"wealth" =~ /[hw]ealth/       # => 0
"realth" =~ /[hw]ealth/       # => nil

# 1, т.к. получается лишь один символ, а не их последовательности
"stealth" =~ /[st]ealth/       # => 1
```

Можно, также, использовать диапазоны

```ruby
"8" =~ /[0-9a-z]/       # => 0
"f" =~ /[0-9a-z]/       # => 0
```

[^some symbols] - крышка в начале значит всё, кроме символов внутри

```ruby
"2" =~ /[^0-9]/       # => nil
"b" =~ /[^0-9]/       # => 0
```

### Специальные escape-последовательности:
Т.к. они слишком часто используются, для них решили выделить целые символы:

```ruby
/\d/  # (digit)- любое целое число
/\w/  # (word)- любое целое, алфавитный символ или '_'
/\s/  # (space)- любой пустой символ - пробел, таб, перевод строки(!?!?!)
```

Каждый из этих символов имеет обратную форму

```ruby
/\D/  # Всё, кроме целых чисел
/\W/  # Всё, кроме любых целых, алфавитных символов и '_'
/\S/  # Всё,кроме пробельных символов
```

### Символы-повторители
Существуют символы, указывающие, сколько раз следует повторять паттерн

* ? - ноль или один
* \+ - один или больше
* \* - ноль или больше
* {5} - именно пять раз
* {2, 8} - от двух до восьми
* {2,} - два или больше
* {,4} - до четырёх

```ruby
/(hello )?world!/.match("hello world!")   # regexData
/(hello )?world!/.match("bye world!")     # regexData
/.*world!/.match("hello there, world!")   # regexData
/(hi ){1, 3}.+/.match("hi hi Mathew")     # regexData
```

### Захват строк
Регулярки исользуются так-же для захвата строк с помощью оператора '()'.
Чем раньше скобка, тем у неё меньше индекс.

```ruby
fullNameRegex = /([A-Z][a-z]+ ){3}/
matchData = dateRegex.match("Matthew David McConaughey")

matchData.captures        # => ["Matthew", "David", "McConaughey"]
name = matchData[0]       # => "Mathew"
patronymic = matchData[1] # => "David"
surname = matchData[2]    # => "McConaughey"
```

Группировка без захвата(например, для применения к строкам символов повторения)
реализуются при помощи символа '?:':

```ruby
/(?:20|19){2}/.match("2020").captures   # => []
```

### Границы
* ^ - указывает на начало строки
* $ - указывает на конец строки
* \b - указывает на начало слова
* \B - указывает на конец слова

```ruby
# Шестнадцатеричное число в C-нотации
/^0x[0-9a-fA-F]{1,8}$/
# подходит: 0x5f3759df, 0xDEADBEEF
# не подходит: 0x1234xxx, xxx0x5678, xxx0x9ABCxxx

/\bruby\B/
# подходит: hello ruby
# не подходит: hello rubymine
```

### Примеры использования из реальной жизни
```ruby
# Замена части предложения
"My name is Andrew".sub /My name is/, "Hi, I'm"   # => "Hi, I'm Andrew"
"The man in the park".gsub /the/, "a"             # => "a man in a park"

# Добавление символов в предложение
"1234567890".sub /(\d{3})(\d{3})(\d{4})/, '(\1) \2-\3' # => "(123) 456-7890"

# Вытащить все ссылки на простые(лишь с тегом src) изображения из raw html
require "open-uri"

imgLinks = /<img\s+src=\"(.+)\"\/>/.match(File.open("somePage.html").read)

imgLinks.each_with_index do |link, index|
  File.open('img' + index ".img", 'wb') do |file|
    file.write open(link).read
  end
end

# Валидация форм
dayRegex = /(0[1-9]|1[0-9]|2[0-9]|3[0-1])/
monthRegex = /jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec/i
yearRegex = /(201[4-9]|202[0-9])/
dateRegex = /#{dayRegex}-#{monthRegex}-#{yearRegex}/

fullNameRegex = /([A-Z][a-z]+ ){3}/

phoneNumberRegex = /(+7|8)\d{10}/
```

### Послесловие
На этом всё, остальное - дело практики.
Мой любимый сайт для тестирования регулярок это [regex101.com](https://regex101.com/)
А если практиковаться не хочется, то всегда можно попробовать просто нагуглить нужную регулярку :)

Эй, до встречи :smile: И оставайся, таким же офигенным, читатель :wink:
